#X3D V3.2 utf8
PROFILE Interchange
COMPONENT CubeMapTexturing:3

# Beautiful water by shader effects.
#
# - 1st effect modifies normals per fragment, to simulate waves.
#
# - 2nd effect provides normals in tangent space for the 1st effect:
#   - from texture (MovieTexture storing normalmaps)
#   - or from GPU generated noise.
#     This results in a smoother look (GPU noise has no texture pixelization),
#     but requires better GPU. Some GPUs may be slower,
#     and the worst graphic driver in the world (fglrx) may just crash.
#     Works perfectly on NVidia GeForce 450 (although is also slower,
#     but from ~400 FPS to ~200 FPS so still very real-time :) ).
#
#   Press "n" to switch between these two choices. Default is the safer,
#   faster, and less quality: normalmaps from MovieTexture.
#
# - 3rd, independent effect adds reflection / refraction from environment cube map.
#
# The environment cube map texture is not updated every frame,
# for best speed. This isn't entirely correct, as moving the camera
# changes the headlight, and so environment changes.
# Press "Space" to manually regenerate environment cube map texture.

EXTERNPROTO PlaneNotTesselated [
  inputOutput SFBool solid
] [ "../prototypes/useful_proto_plane_tess.x3dv#PlaneNotTesselated" ]

EXTERNPROTO PlaneTesselated [
  inputOutput SFBool solid
] [ "../prototypes/useful_proto_plane_tess.x3dv#PlaneTesselated" ]

# ----------------------------------------------------------------------------
# Inline castle_hall level,
# with some parts that would obstruct nice reflections removed,
# with better sky (and not so black, so it's visible in reflections),
# with different camera.

# Camera settings "encoded" in the VRML declaration below :
# direction 0.0097326347604394 -0.0124771371483802 -0.0122313322499394
# up 0.3761610388755798 -0.4821816682815551 0.7911880612373352
# gravityUp 0 -4.3711388286737929E-008 1
Transform {
  translation -0.7321556210517883 0.7535160779953002 1.0205278396606445
  rotation 1 0 -0 1.5707963705062866
  children DEF View Viewpoint {
    position 0 0 0 # camera position is expressed by translation
    orientation -0.1104519069194793 -0.940571904182434 -0.3211302757263183 2.5159108638763428
  }
}

EXTERNPROTO KambiNavigationInfo [
  inputOnly   SFBool   set_bind
  inputOutput MFFloat  avatarSize
  inputOutput SFBool   headlight
  inputOutput SFFloat  speed
  inputOutput MFString type
  inputOutput SFFloat  visibilityLimit
  outputOnly  SFBool   isBound
  initializeOnly  SFBool   timeOriginAtLoad
] [ "urn:castle-engine.sourceforge.net:node:KambiNavigationInfo",
    "http://castle-engine.sourceforge.net/fallback_prototypes.x3dv#KambiNavigationInfo"
]

KambiNavigationInfo {
  headlight TRUE
  timeOriginAtLoad TRUE
  avatarSize [ 0.05, 0.10 ]
  type "FLY"
  headlightNode DirectionalLight {
    ambientIntensity 0.5
    intensity 0.5
    color 1 1 1
  }
}

Transform {
  rotation 1 0 0 1.57
  children

  Background {
     backUrl "../skies/foggy_sky_back.png"
     bottomUrl "../skies/foggy_sky_bottom.png"
     frontUrl "../skies/foggy_sky_front.png"
     leftUrl "../skies/foggy_sky_left.png"
     rightUrl "../skies/foggy_sky_right.png"
     topUrl "../skies/foggy_sky_top.png"
  }
}

Transform {
  children Transform {
    scale 0.05 0.05 0.05
    translation 0 0 -0.1
    children [
      PointLight {
        location  10  10 10
        color 0.3 0.3 0.3
      }
      PointLight {
        location -10 -10 10
        color 0.3 0.3 0.3
      }
      Inline { url "castle_hall_for_water_demo.wrl" }
    ]
  }
}

DEF Timer TimeSensor { loop TRUE }

# ----------------------------------------------------------------------------
# Waves geometry and shader.
# Geometry is trivial, just a flat plane, the whole magic happens
# in the GLSL effects.

Collision {
  enabled FALSE
  children Shape {
    appearance Appearance {
      material DEF MA_Material Material {
        diffuseColor 0.5 0.5 1
        specularColor 1 1 1
        shininess 0.0976563021540641
        transparency 0.2
      }

# Thanks to our effects, you could even add here a normal texture.
#      texture ImageTexture { url "../textures/test_texture.png" }

      effects [
        Effect {
          language "GLSL"
          parts [
            EffectPart { type "VERTEX" url "water_normal.vs" }
            EffectPart { type "FRAGMENT" url "water_normal.fs" }
          ]
        }

        DEF NormalsFromTexture Effect {
          language "GLSL"
          enabled TRUE
          initializeOnly SFNode normalMap
            MovieTexture { url "baked_normals_low_res_seamless/baked_normals_%4d.png" loop TRUE }
          parts [
            EffectPart { type "FRAGMENT" url "water_normalmap.fs" }
          ]
        }

        DEF NormalsFromGPUNoise Effect {
          language "GLSL"
          enabled FALSE
          initializeOnly SFNode white_noise ImageTexture3D {
            url "../textures/white_noise_3d.dds"
            repeatS TRUE
            repeatT TRUE
            repeatR TRUE
            textureProperties TextureProperties { minificationFilter "NEAREST_PIXEL" }
          }
          inputOnly SFTime time
          ROUTE Timer.time TO NormalsFromGPUNoise.time
          parts [
            EffectPart { type "FRAGMENT" url "../compositing_shaders/noise.glsl" }
            EffectPart { type "FRAGMENT" url "water_normalnoise.fs" }
          ]
        }

        DEF ReflectRefractEffect Effect {
          language "GLSL"
          initializeOnly SFNode envMap
            DEF GenTex1 GeneratedCubeMapTexture {
              #update "ALWAYS"
              update "NEXT_FRAME_ONLY"
              size 512
            }
          inputOutput SFMatrix3f cameraRotationInverseMatrix
            1 0 0
            0 1 0
            0 0 1
          parts [
            EffectPart { type "VERTEX" url "water_reflect_refract.vs" }
            EffectPart { type "FRAGMENT" url "water_reflect_refract.fs" }
          ]
        }
      ]
    }
    geometry PlaneTesselated { solid FALSE }
  }
}

ROUTE View.cameraRotationInverseMatrix TO ReflectRefractEffect.cameraRotationInverseMatrix

# Key handling -----------------------------------------------------------------

DEF KeyS KeySensor { }

DEF Scr Script {
  inputOnly SFString key_press
  outputOnly SFString tex_update
  inputOutput SFBool normals_from_texture TRUE
  outputOnly SFBool normals_from_gpu_noise

  url "castlescript:

function key_press(value, timestamp)
  when (value = ' ',
    tex_update := 'NEXT_FRAME_ONLY'
  );
  when (value = 'n',
    { Negate both normals_from_gpu_noise and normals_from_texture,
      knowing they are already negations of each other. }
    normals_from_gpu_noise := normals_from_texture;
    normals_from_texture := not(normals_from_texture)
  )
"
}

ROUTE KeyS.keyPress TO Scr.key_press

ROUTE Scr.tex_update TO GenTex1.update
ROUTE Scr.normals_from_texture TO NormalsFromTexture.enabled
ROUTE Scr.normals_from_gpu_noise TO NormalsFromGPUNoise.enabled
