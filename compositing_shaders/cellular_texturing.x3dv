#X3D V3.2 utf8
PROFILE Interchange
COMPONENT Shaders:1

# Very simple test of cellular texturing --- a technique of making
# procedural textures that look like Voronoi diagrams.
# This is a very basic and naive implementation, just to test that they
# work.

Background { skyColor 0 0 0 }

# Camera settings "encoded" in the VRML/X3D declaration below :
# direction 0.2985724806785583 -0.574532151222229 -0.7620806694030761
# up -0.0172877218574285 0.7951160669326782 -0.6062106490135192
# gravityUp 0 1 0
Viewpoint {
  position -0.6996809244155883 2.1671843528747559 4.5905947685241699
  orientation -0.9014652371406555 -0.4016170501708984 0.1614447087049484 0.7140532135963439
}

Shape {
  appearance DEF App Appearance {
    # unlit looks better?
    #material Material { }
    texture ShaderTexture {
      effects Effect {
        language "GLSL"
        parts EffectPart {
          type "FRAGMENT"
          url "data:text/plain,

/* Note: This requires on newer GLSL version, at least 120, for some syntax. */

const int count = 30;

/* It would be cleaner to mark these arrays as 'const vec3',
   not ugly hacky 'uniform vec3'. But 'uniform vec3' works much
   faster (NVidia GeForce GTS 450). */

uniform vec3 feature_points[count] = vec3[count](
  vec3(0.12, 0.08, 0.61),
  vec3(0.08, 0.61, 0.99),
  vec3(0.78, 0.40, 0.85),
  vec3(0.45, 0.58, 0.32),
  vec3(0.50, 0.38, 0.03),
  vec3(0.64, 0.27, 0.84),
  vec3(0.15, 0.89, 0.61),
  vec3(0.86, 0.37, 0.13),
  vec3(0.29, 0.81, 0.00),
  vec3(0.92, 0.77, 0.43),
  vec3(0.01, 0.86, 0.24),
  vec3(0.84, 0.27, 0.95),
  vec3(0.17, 0.17, 0.75),
  vec3(0.33, 0.91, 0.40),
  vec3(0.40, 0.11, 0.32),
  vec3(0.50, 0.71, 0.81),
  vec3(0.11, 0.86, 0.18),
  vec3(0.61, 0.83, 0.51),
  vec3(0.77, 0.83, 0.80),
  vec3(0.56, 0.97, 0.35),
  vec3(0.77, 0.97, 0.94),
  vec3(0.13, 0.21, 0.62),
  vec3(0.06, 0.16, 0.23),
  vec3(0.14, 0.46, 0.90),
  vec3(0.79, 0.28, 0.49),
  vec3(0.31, 0.79, 0.01),
  vec3(0.78, 0.68, 0.91),
  vec3(0.23, 0.11, 0.88),
  vec3(0.05, 0.65, 0.32),
  vec3(0.80, 0.12, 0.76)
);

uniform vec3 feature_colors[count] = vec3[count](
  vec3(1.0 , 1.0 , 0.0 ),
  vec3(1.0 , 0.0 , 0.0 ),
  vec3(0.5 , 0.5 , 1.0 ),
  vec3(0.0 , 1.0 , 0.0 ),
  vec3(0.5 , 1.0 , 1.0 ),
  vec3(1.0 , 1.0 , 1.0 ),
  vec3(0.94, 0.68, 0.03),
  vec3(0.28, 0.79, 0.63),
  vec3(0.94, 0.64, 0.56),
  vec3(0.06, 0.38, 0.52),
  vec3(0.66, 0.19, 0.08),
  vec3(0.68, 0.46, 0.89),
  vec3(0.50, 0.63, 0.27),
  vec3(0.62, 0.15, 0.76),
  vec3(0.06, 0.39, 0.75),
  vec3(0.99, 0.10, 0.39),
  vec3(0.62, 0.32, 0.98),
  vec3(0.82, 0.24, 0.17),
  vec3(0.27, 0.02, 0.35),
  vec3(0.28, 0.94, 0.94),
  vec3(0.49, 0.27, 0.53),
  vec3(0.83, 0.31, 0.34),
  vec3(0.93, 0.74, 0.61),
  vec3(0.53, 0.53, 0.96),
  vec3(0.31, 0.01, 0.34),
  vec3(0.77, 0.64, 0.17),
  vec3(0.81, 0.97, 0.32),
  vec3(0.44, 0.91, 0.45),
  vec3(0.65, 0.52, 0.45),
  vec3(0.10, 0.76, 0.43)
);

void PLUG_texture_color(inout vec4 texture_color,
  const in vec4 tex_coord)
{
  float[count] distances;

  int closest0, closest1;

  /* calculate 1st and 2nd distances first, to initialize closest */
  distances[0] = distance(vec3(tex_coord), feature_points[0]);
  distances[1] = distance(vec3(tex_coord), feature_points[1]);

  if (distances[0] < distances[1])
  {
    closest0 = 0;
    closest1 = 1;
  } else
  {
    closest0 = 1;
    closest1 = 0;
  }

  for (int i = 2; i < count; i ++)
  {
    vec3 d = vec3(tex_coord) - feature_points[i];
    distances[i] = dot(d, d); /* square of the actual distance */
    /* update closest0 */
    if (distances[i] < distances[closest0])
    {
      closest1 = closest0;
      closest0 = i;
    } else
    if (distances[i] < distances[closest1])
      closest1 = i;
  }

  texture_color.rgb = pow(sqrt(distances[closest1]) - sqrt(distances[closest0]), 0.3)
    * 2.0 * feature_colors[closest0];
}
"
        }
      }
      defaultTexCoord "BOUNDS3D"
    }
  }
  geometry Teapot { }
}

Transform { translation 3  0 0 children Shape { appearance USE App geometry Cone   { } } }
Transform { translation 3 -3 0 children Shape { appearance USE App geometry Box    { } } }
Transform { translation 0 -3 0 children Shape { appearance USE App geometry Sphere { } } }

# Random vectors may be generated by this trivial program:
# uses SysUtils;
# var
#   I: Integer;
# begin
#   Randomize;
#   for I := 1 to 90 do
#   begin
#     Writeln(Format('vec3(%f, %f, %f),', [Random, Random, Random]));
#   end;
# end.
